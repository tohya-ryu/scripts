#!/usr/bin/ruby
require 'gpi'
require 'yaml'

$repeat = false

GPI.app_name = "amntr"
GPI::CLU.init

if ENV['HOME'] != '/root'
  GPI.print "error: requires root user (sudo #{GPI.app_name})"
  GPI.quit
end

GPI::CLU.use_command("m", 0..1, "")
GPI::CLU.use_command("u", 0..1, "ae")
GPI::CLU.process_args

HOME = ENV['LOGNAME']

# ignore these block devices
IGNO_DEV = [ "sda" ]

# encrypted partitions
CRYPT_PART = { "mapper_name" => "uuid" }
MAPPER = { "mapper_name" => "uuid" }

# also ignore block devices with partitions having any of these uuids
IGNO_PART = Array.new

# do not dismount home partitions without option -a
HOME_UUID = [ "uuid" ]

# chown 1000:1000 for all ext4 drives
EXT4_CHOWN = [ "uuid" ]

#        block device uuid      mount point
STAT = { "uuid" => "path_to_mount_at" }

# read block devices
blk = BlockDevice.read_all

blk.each do |b|

  b.partitions.reverse! if GPI::CLU.command == 'u'

  b.partitions.each do |p|
    if GPI::CLU.parameters.length > 0
      p.process if GPI::CLU.parameters.include?(p.name)
    else
      p.process
    end
  end
  if GPI::CLU.command == 'u' && GPI::CLU.check_option('e')
    # eject ! powerdown device
    b.eject if b.mounted_n == 0
  end
  GPI.print "done"
end

# quick hack to accomodate freshly opened encrypted partitions
if $repeat
  GPI.print "repeat!"
  blk = BlockDevice.read_all

  blk.each do |b|

    b.partitions.reverse! if GPI::CLU.command == 'u'

    b.partitions.each do |p|
      if GPI::CLU.parameters.length > 0
        p.process if GPI::CLU.parameters.include?(p.name)
      else
        p.process
      end
    end
    GPI.print "repeat done"
  end
end



###############################################################################
BEGIN {

class Partition
  attr_accessor :name, :uuid, :mnt, :blk, :crypt, :mapper, :mapper_name, :home

  def initialize(blk)
    @blk = blk
    @crypt = false
    @mapper = false
    @mapper_name = ""
    @home = false
  end

  def process
    GPI.print "Processing '#{@name}'"
    case GPI::CLU.command
    when 'm'
      unless mounted?
        mount
      end
    when 'u'
      if mounted? || is_encrypted?
        unmount
      end
    end
  end

  def mount
    GPI.print "mounting #{@name}"
    if STAT.has_key?(@uuid)
      @mnt = STAT[@uuid]
      Dir.mkdir(@mnt) unless Dir.exist?(@mnt)
      GPI.print "created dir #{@mnt}" unless Dir.exist?(@mnt)
    else
      unless is_encrypted?
        i = 0
        while Dir.exist?("/mnt/#{i}") do
            i += 1
        end
        @mnt = "/mnt/#{i}"
        Dir.mkdir(@mnt)
        GPI.print "created dir #{@mnt}"
      end
    end
    if is_encrypted?
      cmd = "cryptsetup status #{@mapper_name}"
      GPI.print cmd
      cmd_response = `#{cmd}`
      if cmd_response.include? "is inactive"
        GPI.print "opening encrypted partition"
        cmd = "cryptsetup luksOpen /dev/#{@name} #{@mapper_name}"
        GPI.print cmd
        if system("#{cmd}")
          @blk.mounted_n += 1
          $repeat = true
        end
      elsif cmd_response.include? "is active"
        GPI.print "encrypted partition already active, skip opening"
        @blk.mounted_n += 1
      end
    elsif is_mapper?
      GPI.print "mounting encryption mapper"
      cmd = "mount /dev/mapper/#{@mapper_name} #{@mnt}"
      system("#{cmd}")
      @blk.mounted_n += 1
    else
      cmd = "mount /dev/#{@name} #{@mnt}"
      GPI.print cmd
      system("#{cmd}")
      @blk.mounted_n += 1
    end
    if EXT4_CHOWN.include?(@uuid)
      cmd = "chown 1000:1000 #{@mnt}"
      GPI.print cmd
      system("#{cmd}")
    end
  end

  def unmount
    if @home && !GPI::CLU.check_option('a')
      GPI.print "skipping home partition #{@name}"
      return
    end
    if is_encrypted?
      flag = false
      @blk.partitions.each do |p|
        if p.mapper && p.mapper_name == @mapper_name && !p.mounted?
          flag = true
          break
        end
      end
      if flag
        cmd = "cryptsetup luksClose #{@mapper_name}"
        GPI.print cmd
        if system(cmd)
          @blk.mounted_n -= 1
          GPI.print "closed #{@mapper_name}"
        end
      end
    else
      cmd = "umount #{@mnt}"
      GPI.print cmd
      if system("#{cmd}")
        GPI.print "dismounted #{@mnt}"
        @blk.mounted_n -= 1
        Dir.rmdir(@mnt)
        GPI.print "removed dir #{@mnt}"
        @mnt = ""
      else
        GPI.print "failed to dismount #{@mnt}"
      end
    end
  end

  def mounted?
    @mnt != ""
  end

  def is_mapper?
    @mapper
  end

  def is_encrypted?
    @crypt
  end
end

class BlockDevice
  attr_accessor :mounted_n, :home
  attr_reader :name, :partitions

  def initialize(name)
    @name = name
    @partitions = Array.new
    @ignore =  IGNO_DEV.include?(name)
    @home = false
    @mounted_n = 0
  end

  def eject
    GPI.print "ejecting disk #{@name}."
    %x{ udisksctl power-off --block-device /dev/#{@name} }
    GPI.print "finish."
  end

  def add_partition(data)
    p = Partition.new(self)
    p.name = data[:name][2..-1]
    p.uuid = data[:uuid]
    p.mnt  = data[:mnt]
    p.home = true if HOME_UUID.include?(p.uuid)
    @mounted_n += 1 if p.mounted?
    CRYPT_PART.each do |k,v|
      if p.uuid == v
        p.crypt = true
        p.mapper_name = k
      end
    end
    MAPPER.each do |k,v|
      if p.uuid == v
        p.mapper = true
        p.mapper_name = k
      end
    end
    @partitions.push p
  end

  def ignored?
    @ignore
  end

  def BlockDevice.read_all
    dev_skip = false
    positions = Array.new
    blkdevs = Array.new
    str = %x{ lsblk -f }
    i = 0
    k = 0
    str.each_line do |l|
      if i == 0
        j = 0
        b = -1
        e = -1
        l.each_char do |c|
          if c == " "
            if l[j+1] != " "
              e = j
            else
              e = -1
            end
          else
            b = j if b == -1 # set beginning
            e = -1
            if l.length == j+1
              e = j
            end
          end
          if b != -1 && e != -1
            e -= 1
            if str.length == j+1
              positions.push b..-1
            else
              positions.push b..e
            end
            b = -1
          end
          j += 1
        end
      end
      i += 1
      next if i == 1 # no need to process line[0]
      h = Hash.new
      h[:name] = l[positions[0]].strip
      #fstype = l[positions[1]].strip
      #label = l[positions[2]].strip
      h[:uuid] = l[positions[3]].strip
      #fsavail = l[positions[4]].strip
      #fuse = l[positions[5]].strip
      h[:mnt] = l[positions[6]].strip

      if h[:name].match? /\Asd[a-z]\z/
        if IGNO_DEV.include?(h[:name])
          GPI.print "Skipping #{h[:name]}"
          dev_skip = true
        else
          dev_skip = false
        end

        blkdevs.push BlockDevice.new(h[:name]) unless IGNO_DEV.
          include?(h[:name])
      else
        unless dev_skip
          GPI.print "Skipping Partition #{h[:name][2..-1]}" if IGNO_PART.
            include?(h[:uuid])
          blkdevs.last.add_partition(h) unless IGNO_PART.include?(h[:uuid])
        end
      end

    end
    blkdevs
  end

end
}
